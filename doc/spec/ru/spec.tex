%\subsection{Основные особенности}
%Далее будут перечислены основные особенности предлагаемого языка:
В данном разделе будет представлен язык ЯЗ.
Основные особенности ЯЗ можно определить следующим образом:
\begin{enumerate}
\renewcommand{\labelenumi}{\theenumi.}
\renewcommand{\theenumi}{F\arabic{enumi}}


    \item ЯЗ является языком запросов, который позволяет осуществлять выборку по объектной 
    модели. %, определенной в~\cite{ODMG_3}.
%    \item ЯЗ позволяет преобразовывать выборку в необходимый для пользователя вид. 
%Данная возможность осуществима через вызов функции.
    \item\label{cut_query} ЯЗ самостоятельно выводит связи между объектами. 
%Для сокращения записи запроса язык предоставляет пользователю следующие возможности:
%	\begin{itemize}
%	
%	    \item не указывать связи между объектами (такие связи должны выводиться автоматически во время
%	выполнения запроса, например, строиться на основе метаинформации о модели);
%	    \item сокращать имена классов модели;
%	    \item сокращать сложные условия применяемые к одному свойству элемента.	    
%	\end{itemize}

    \item ЯЗ позволяет получать всю иерархию рекурсивных ссылок.
    \item ЯЗ предоставляет возможность вызова функции с данными из БД в качестве параметров. 
	Полученный от функции результат может стать результатом (или частью результата) запроса. 

\end{enumerate}

\subsection{Структура результата запроса}
Результатом запроса является:
    \begin{itemize}
	\item элемент, если структура результата состоит из одной структуры кортежа,
	    а запрос подразумевает один элемент в наборе кортежей в следующих случаях: 
	    \begin{itemize}
		\item кортеж результата содержит один элемент и выбирается только один кортеж;
		\item вызов функции как результата запроса 
		    (например, вызов функции суммирования по одному из свойств объекта).
	    \end{itemize}
	\item набор кортежей в любом другом случае.
    \end{itemize}

\subsubsection{Простая выборка}\label{simple-select}
Чтобы выбрать множество объектов заданного класса, достаточно задать имя класса:
\query{Room}
Данный запрос вернет пользователю множество объектов \cl{Room}.
Стуктура кортежа запроса состоит из одного элемента, типом
которого является класс \cl{Room}, поэтому каждый кортеж запроса
будет состоять из одного объекта класса \cl{Room}.
Если для класса не существует другого класса с таким же именем, но различным регистром
в написании всего имени или его отдельных букв (например, \cl{Room} и \cl{room}),
то для этого класса регистром можно пренебречь:
\query{room}

Также можно сокращать имена классов (в том случае если не возникает коллизий: 
например, если существует два класса, начинающиеся с буквы ``R'', то сократить
имя класса до ``r'' нельзя):
\query{r \\ro \\ roo}

Пользователь может самостоятельно определить сокращение для имени класса (механизм
задания таких сокращений определяется реализацией):
\query{rm}

Если сокращение пользователя для одного класса соответсвует одному из сокращений
другого класса, то в запросе должно подразумеваться сокращение пользователя.

Обращение к свойствам объекта необходимо производить через точку.  
Если необходимо выбрать свойство \cl{name} объекта \cl{Room}, 
то сделать это можно следующим образом:
\query{room.name}
В результат данного запроса будет включено значение свойства \cl{name} каждого объекта \cl{Room}.
Вложенность обращений неограничена:
\query{room.floor.building.name}

Помимо свойства, ЯЗ позволяет возвращать значение результата выполнения метода объекта.
Вызов его также осуществляется через точку, а результат выполнения включается в кортеж
результата запроса. Параметры метода задаются через запятую в круглых скобках после
имени метода. В том случае если метод не имеет параметров, то круглые скобки можно опускать.
Метод не может ничего не возвращать. Если это происходить, то пользователь должен получить
сообщение об ошибке. В преположении того, что метод \cl{getName} класса \cl{Room} возвращает
значение свойства \cl{name}, то результат данного запроса
\query{room.getName()}
будет эквивалентен результату запроса
\query{room.name}


Одной из особенностей ЯЗ является то, что ЯЗ пытается самостоятельно искать связи между 
объектами (подробнее см. в~\ref{tied_queries}). Поэтому в запросах на ЯЗ можно
сразу после точки указать имя другого класса, с которым неоходимо связать объекты.
В таком случае запрос
\query{room.networkinterface.inetAddress}
будет корректен и вернет значение свойства \cl{inetAddress} объектов \cl{networkinterface},
принадлежащих объектам \cl{room}. Корректность определяется тем, что между классами
\cl{Room} и \cl{NetworkInterface} существует связь, которая будет найдена
ЯЗ и применена для получения объектов \cl{networkinterface} для конкретно взятого
объекта \cl{room}.

Язык также предоставляет возможность обращения к коллекциям
элементов, при этом подразумевается, что такое обращение идет к объекту находящемуся в
коллекции, а не к самой коллекции.
Например, в таком запросе
\query{building.floors.number}
\cl{floors} представляет собой коллекцию, состоящую из объектов \cl{Floor}, поэтому
обращение \cl{.number} идет не к типу коллекции, а к типу элемента коллекции (т.е. к \cl{Floor}).
Данный запрос вернет номера (\cl{number}) этажей(\cl{Floor} из \cl{floors}), принадлежащих зданиям 
(\cl{building}).

Если необходимо выбрать несколько свойств объекта, то сделать это можно так:
\query{room[name number]}
Кортеж результата данного запроса будет состоять из двух элементов: для каждого объекта \cl{Room}
в результат будет включено значение свойства \cl{name} и \cl{number}.

Как следует из вышесказанного, через точку может задаваться как свойство или метод объекта, так и
имя класса другого объекта, с которым данный объект необходимо связывать. Реализация ЯЗ
должна осуществлять поиск отношения в соответствии со следующим списком приоритетов, расположенных в
порядке убывания: 
\begin{itemize}\addtolength{\itemsep}{-0.7\baselineskip}
    \item свойство;
    \item метод;
    \item связь между двумя классами модели;
    \item поиск в наследниках или родителях (подробнее см. главу про полиморфизм).
% связь между наследниками и родителями .
\end{itemize}





\subsubsection{Выборка связанных элементов}\label{tied_queries}
Если необходимо выбрать связанные между собой объекты (предполагается, что между ними
существует связь на уровне модели), то необходимо задать связь, используя круглые скобки.
Например, запрос 
\query{building (room)}
на естественном языке можно сформулировать так: выбрать все здания (\cl{building}) и для каждого
здания показать список его комнат (\cl{room}). Скобки определяют следующий уровень иерархии
результата запроса (данный запрос имеет 2 уровня иерархии). Такой запрос возможен потому, что класс \cl{Building} связан с
классом \cl{Room} и существует возможность однозначно определить данную связь:
\cl{Building} имеет коллекцию \cl{floors}, состояющую из объектов \cl{Floor}, которые в 
свою очередь имеют коллекцию \cl{rooms}, состояющую из объектов \cl{Room}. Таким образом, 
для каждого объекта класса \cl{Building} имеется возможность найти множество принадлежащих ему
объектов класса \cl{Room}.
%В том случае если связь однозначно определить нельзя, то можно самостоятельно ее указать в запросе:
%\query{
    %building\#b (b.floor.room)
%    building (floor.room)
%}

%После имени класса через знак ``\#'' указано имя, на которое можно ссылаться далее
%по тексту запроса. Указание имени ссылки в данном случа обязательно, так как
%при таком запросе
%\query{building (building.floor.room)}
%или использовании любого другого сокращения
%\query{
%    building (b.floor.room)\\
%    building (buil.floor.room)
%}
%будет производиться поиск связи между объектами класса \cl{Building}.

Если невозможно найти связь между двумя указанными объектами, то пользователь должен
получить сообщение об ошибке. Если между объектами существует несколько
связей, то выбирается та связь, для которой требуется меньшее количество переходов по ссылкам.
Если существует несколько связей с одинаковой минимальной длиной переходов, то 
выбирается произвольная из этих связей.

Также существует возможность указания промежуточных звеньев связи:
\query{
    %building\#b (b.room.device)
    building (room.device)
}
С помощью данного запроса пользователь сможет получить список зданий(\cl{building}) и все 
принадлежащие ему устройства (\cl{device}). При этом он указывает, что эти устройства необходимо
искать у здания через комнаты (\cl{room}), т.е. сначала будет произведен поиск связи от здания
до комнаты, а потом от комнаты до устройств. Такая возможность может быть полезна при 
существовании нескольких связей между объектами. В этом случае можно идентифицировать
одну связь, указав промежуточное звено. 

Стоит обратить внимание, что поиск связи осуществляется по объектам классов модели, 
а не по их свойствам. Таким образом такие запросы будут некорректны:
\query{
    building (rooms)\\
    %building\#b (b.rooms.devices)
    building (rooms.devices)
}


Вложенность связей неограничена:
\query{building (room (device (networkinterface)))}
Кортеж данного запроса будет состоять из четырех элементов (запрос имеет четыре уровня иерархии): 
здание (\cl{building}), у каждого здания необходимо показать множество его комнат (\cl{room}), 
у каждой комнаты --- множество устройств (\cl{device}), 
а у каждого устройства --- множество его сетевых интерфейсов (\cl{networkinterface}).

Язык позволяет определять несколько типов элементов на одном уровне иерархии. Например,
такой запрос
\query{building (room, device)}
вернет список зданий, а для каждого здания список его комнат и устройств. При этом
в кортеже результата данного запроса будет всего два элемента. Второй элемент будет
либо комнатой (\cl{room}), либо устройством (\cl{device}). Поиск связи будет производиться
независимо два раза: от здания до комнаты и от здания до устройства.

В случае с несколькими элементами на одном уровне иерархии и последующим связыванием
следует придерживаться следующего правила: элемент на следующем уровне иерархии 
привязывается к последнему элементу предыдущего уровня иерархии. Таким образом,
в запросе
\query{builidng (room, simpleou (device))}
список устройств (\cl{device}) будет формироваться относительно простых
организационных единиц (\cl{simpleou}).

Еще примеры:
\queryexpl{\cl{floor} привязывается к \cl{room}}{building.device.room (floor)}
\queryexpl{\cl{floor} привязывается к \cl{device}}{(building.device).room (floor)}
\queryexpl{\cl{floor} привязывается к \cl{building}}{(building).device.room (floor)}




\subsubsection{Объединение запросов}
ЯЗ позволяет объединять результаты запросов в одном запросе. Объединение запросов 
выполняется при помощи запятой. Таким образом, объединение запросов представляет
собой задание нескольких структур кортежей на первом уровне иерархии. Например, запрос
\queryexpl{Получить все здания и комнаты}{building, room}
вернет список объектов \cl{Building} и \cl{Room} (результат см. в~\ref{ex_3}). 

Структура объединенных запросов может быть различна. Там где значение не определено, 
результат запроса должен содержать значение NOT\_DEFINED (в ЯЗ4J для обозначения
такого значения используется \cl{NOT\_DEFINED} перечисления \cl{Definitions}.).
Например, в запросе
\query{building (room), floor}
структура первого запроса отличается от структуры второго запроса (результат его выполнения
см. в~\ref{ex_5}). Первый запрос возвращает кортежи с двумя элементами, а второй --- с одним.

%Приведем еще несколько примеров:
%\query{building (room (device), device)}
%В данном запросе кортеж состоит из трех элементов.






\subsubsection{Выборка объектов по рекурсивным ссылкам}
Предположим, что у нас есть класс {\it Person}, описание структуры которого на псевдокоде выглядит так:
\begin{verbatim}
    class Person {
        String name = "";
        String surname = "";
        Person father = null;
        Person mother = null;
        Set<Person> children = new HashSet<Person>();
    }
\end{verbatim}
Данный класс имеет поля \cl{father} и \cl{mother}, которые также имеют тип \cl{Person} и поле-коллекцию
\cl{children}, состоящую из объектов типа \cl{Person}, которые в свою очередь также будут иметь
поля \cl{father},  \cl{mother} и \cl{children} и так далее. Как в таком случае получить всю 
иерархию объектов, например, по полю \cl{father}? Для этого в ЯЗ введены специальные
модификаторы, которые позволяют это сделать:
\query{person.father*}
или
\query{person.father+}
Оператор \cl{+} отличается от \cl{*} тем, что при \cl{+} в результат запроса будут
включены только объекты \cl{father}, тогда как при \cl{*} в результат также 
попадет сам объек \cl{person}.

Запрос с \cl{+} для каждого объекта \cl{person} найдет объект \cl{person.father} и включит
его в кортеж результата. Если найденный объект не представляет
из себя пустое значение, то будет найден объект \cl{person.father.father}, который будет 
включен следующим элементов кортежа. Такой поиск будет происходить до тех пор, пока не будет
найдено пустое значение. 
При запросе с \cl{*} в результат запроса сначала будет включен сам объект \cl{person}. 
Затем для этого объекта будет найден объект \cl{person.father}, который станет
следующим элементом кортежа. Если \cl{person.father} не равен пустому значению, то будет найдет
\cl{person.father.father} и включен в результат и так далее.

Если необходимо включать не сам объект \cl{person.father}, а, 
одно из его свойств, например, поле \cl{name}, то это можно сделать следующим образом:
\query{person.father*.name}

Модель на рис.~\ref{fig:son-model} также имеет рекурсивные ссылки: 
класс \cl{AbstractOU}, наследниками которого являются классы \cl{CompositeOU} и \cl{SimpleOU},
содержит поле \cl{parent}, имеющее тип \cl{CompositeOU}. Таким образом, чтобы для каждого 
\cl{SimpleOU} получить все его вышестоящие подразделения необходимо выполнить следующий запрос:
\query{simpleou.parent+}

Для примера организационной модели, приведенного на рис.~\ref{fig:model-snapshot-org}, 
данный запрос вернет следующий результат:\footnote{Если элементом результата запроса 
является объект, то в таблице с результатом приводится его строковое представление.}


\begin{center}
    \begin{tabular}{|l|l|}
	\hline
	\it{parent} & \it{parent}\\[5pt]
	\hline
	\hline
	IT-Отдел & ПетрГУ \\
	\hline
	IT-Отдел & ПетрГУ \\
	\hline
	ОргОтдел & ПетрГУ \\
	\hline
	МатФак & ПетрГУ \\
	\hline
    \end{tabular}
\end{center}

Если необходимо включить в результата запроса сам \cl{simpleou}, то для этого нужно
выполнить запрос
\query{simpleou.parent*},
который вернет следующий результат:
\begin{center}
    \begin{tabular}{|l|l|l|}
	\hline
	\it{simpleou} & \it{parent} & \it{parent}\\[5pt]
	\hline
	\hline
	1C автоматизация & IT-Отдел & ПетрГУ \\
	\hline
	Отдел безопасности & IT-Отдел & ПетрГУ \\
	\hline
	По международным связям & ОргОтдел & ПетрГУ \\
	\hline
	Кафедра ИМО & МатФак & ПетрГУ \\
	\hline
    \end{tabular}
\end{center}


\begin{figure}[hbt]
  \centering
  \includegraphics[scale=0.5]{figures/model_snapshot_org_petrsu}
  \caption{Пример организационной структуры модели Nest}
  \label{fig:model-snapshot-org}
\end{figure}


Запрос ``найти все вышестоящие отделы для всех \cl{CompositeOU} модели'' может быть
задан так
%Еще один пример на модели, приведенной на рис.~\ref{fig:model-snapshot-org}.
\query{compositeou.parent+}
и даст следующий результат:
\begin{center}
    \begin{tabular}{|l|l|}
	\hline
	\it{parent} & \it{parent}\\[5pt]
	\hline
	\hline
	\cl{null} & \cl{null} \\
	\hline
	ПетрГУ & \cl{null}\\
	\hline
	ПетрГУ & \cl{null}\\
	\hline
	ПетрГУ & \cl{null}\\
	\hline
	ОргОтдел & ПетрГУ \\
	\hline
    \end{tabular}
\end{center}

Если необходимо включить в запрос сам \cl{compositeou}, то для этого нужно
выполнять запрос
\query{compositeou.parent*},
который даст следующий результат:
\begin{center}
    \begin{tabular}{|l|l|l|}
	\hline
	\it{compositeou} & \it{parent} & \it{parent}\\[5pt]
	\hline
	\hline
	ПетрГУ & \cl{null} & \cl{null}\\
	\hline
	МатФак & ПетрГУ & \cl{null}\\
	\hline
	IT-Отдел & ПетрГУ & \cl{null}\\
	\hline
	ОргОтдел & ПетрГУ & \cl{null}\\
	\hline
	Пресс-Служба & ОргОтдел & ПетрГУ \\
	\hline
    \end{tabular}
\end{center}


Кроме того, класс \cl{CompositeOU} имеет свойство \cl{OUs}, которое является
коллекцией, состоящей из объектов \cl{AbstractOU}. Если необходимо
узнать всю иерархию организационных единиц для всех \cl{CompositeOU} модели,
то это можно сделать с помощью запроса
\query{compositeou.ous*}
, который вернет следующий результат: 
\begin{center}
    \begin{tabular}{|l|l|l|}
	\hline
	\it{compositeou} & \it{ous} & \it{ous}\\[5pt]
	\hline
	\hline
	ПетрГУ &  ЮрОтдел & \cl{null} \\
	\cline{2-3}
		    & ОргОтдел & По международным связям \\
	\cline{3-3}
		    &	       & Пресс-Служба \\
	\cline{2-3}
		    & IT-Отдел & Отдел безопасности\\
	\cline{3-3}
		    &	       & 1C автоматизация \\
	\cline{2-3}
		    & МатФак & Кафедра ИМО \\
	\hline
	ОргОтдел & По международным связям & \cl{null} \\
	\cline{2-3}
		& Пресс-Служба & \cl{null} \\
	\hline
	IT-Отдел & Отдел безопасности & \cl{null} \\
	\cline{2-3}
		& 1C автоматизация & \cl{null} \\
	\hline
	ЮрОтдел & \cl{null} & \cl{null} \\
	\hline
	Пресс-Служба & \cl{null} & \cl{null} \\
	\hline
	МатФак & Кафедра ИМО & \cl{null} \\
	\hline
    \end{tabular}
\end{center}



\subsubsection{Связанные элементы и рекурсивные ссылки}
\begin{figure}[hbt]
  \centering
  \includegraphics[scale=0.5]{figures/model_snapshot_org_spa_big}
  \caption{Пример организационной и пространственной структуры модели Nest}
  \label{fig:model-snapshot-org-spa}
\end{figure}

В запросах с рекурсивными ссылками и связанными элементами на 
последующих уровнях иерархии, связанные элементы будут указываться вместе
с последующим рекурсивным объектом. Например, запрос
\query{simpleou.parent* (room)}
на примере модели, изображенной на рис.~\ref{fig:model-snapshot-org-spa}, 
вернет результат приведенный в таблице~\ref{table:complex-query}.
\begin{table}[p]
  \centering
    \begin{tabular}{|l|l|l|l|}
	\hline
	\it{simpleou} & \it{parent,room} & \it{parent,room} & \it{room} \\[5pt]
	\hline
	\hline
	1C автоматизация & IT-Отдел & ПетрГУ & Room 201\\
	\cline{4-4}
		    &  &  & Room 202\\
	\cline{4-4}
		    &  &  & Room 203\\
	\cline{4-4}
		    &  &  & Room 215\\
	\cline{4-4}
		    &  &  & Room 217\\
	\cline{4-4}
		    &  &  & Room 221\\
	\cline{3-4}
		    &  & Room 201 & \\
	\cline{3-4}
		    &  & Room 202 & \\
	\cline{3-4}
		    &  & Room 203 & \\
	\cline{2-4}
		    & Room 203 & & \\
	\hline
	Отдел безопасности & IT-Отдел & ПетрГУ & Room 201\\
	\cline{4-4}
		    &  &  & Room 202\\
	\cline{4-4}
		    &  &  & Room 203\\
	\cline{4-4}
		    &  &  & Room 215\\
	\cline{4-4}
		    &  &  & Room 217\\
	\cline{4-4}
		    &  &  & Room 221\\
	\cline{3-4}
		    &  & Room 201 & \\
	\cline{3-4}
		    &  & Room 202 & \\
	\cline{3-4}
		    &  & Room 203 & \\
	\cline{2-4}
		    & Room 201 & & \\
	\cline{2-4}
		    & Room 202 & & \\
	\hline
	По международным связям & ОргОтдел & ПетрГУ & Room 201\\
	\cline{4-4}
		    &  &  & Room 202\\
	\cline{4-4}
		    &  &  & Room 203\\
	\cline{4-4}
		    &  &  & Room 215\\
	\cline{4-4}
		    &  &  & Room 217\\
	\cline{4-4}
		    &  &  & Room 221\\

	\cline{3-4}
		    &  & Room 221 & \\
	\cline{2-4}
				& Room 221 &  & \\
	\hline
	Кафедра ИМО & МатФак & ПетрГУ & Room 201\\
	\cline{4-4}
		    &  &  & Room 202\\
	\cline{4-4}
		    &  &  & Room 203\\
	\cline{4-4}
		    &  &  & Room 215\\
	\cline{4-4}
		    &  &  & Room 217\\
	\cline{4-4}
		    &  &  & Room 221\\
	\cline{3-4}
		    &  & Room 215 & \\
	\cline{3-4}
		    &  & Room 217 & \\
	\cline{2-4}
		    & Room 215 & & \\
	\cline{2-4}
		    & Room 217 & & \\
	\hline
    \end{tabular}
    \caption{результат запроса \itshape{\bfseries{simpleou.parent* (room)}}}
    \label{table:complex-query}

\end{table}

Обратите внимание, что \cl{room} привязываются как к самому \cl{simpleou}, так и к
его \cl{parent}, что согласуется с общей концепцией связанных элементов: элемент
на следующем уровне иерархии привязывается к последнему элементу предыдущего уровня
иерархии.

\subsection{Ограничения}
\input{where.tex}

\subsection{Функции}
\input{functions.tex}

\subsection{Группировка}
\input{groupby.tex}

\subsection{Сортировка}
Чтобы определить порядок, в котором будут располагаться 
выбираемые объекты, необходимо после имени класса
в структуре результата запроса указать в фигурных скобках набор полей и способ 
(для этого используются модификаторы \cl{asc} (по возрастанию) и \cl{desc} (по убыванию))
сортировки. Например, в запросе
\query{room\{desc:number\}}
кортежи с объектами \cl{room} будут отсортированы по полю \cl{number} в порядке 
убывания. 

Набор типов, по которым пользователь сможет задавать сортировку,
определяется реализацией данной спецификации.  Если тип выбираемого объекта или свойства объекта
определен в наборе, который поддерживается реализацией для сортировки, то достаточно указать порядок сортировки. 
Например, в запросе 
\query{room.number\{asc\}}
кортежи со строковыми значениями полей \cl{number} объектов \cl{room} будут
отсортированы по возрастанию.

Также можно задать несколько полей, по которым необходимо произвести сортировку. 
Например, объекты \cl{room} в результате запроса
\query{room\{desc:name asc:number\} }
будет вначале отсортирован по полю \cl{name} по убыванию, в случае если значения
\cl{name} совпадают, то затем по полю \cl{number} в порядке возрастания.

Если для порядка используется один модификатор для нескольких подряд идущих полей, 
то эти поля можно указывать после модификатора через запятую. Например:
\query{
    room\{desc:number,name\}\\
    room\{desc:number,name asc:id\}\\
    room\{asc:floor.number desc:number,name asc:id\}
}

Если сортировка применяется к элементу, находящемуся на не первом уровне иерархии, то
сортировка объектов производится внутри каждого кортежа по отдельности. Например, каждый
кортеж результата запроса
\query{building (room\{asc:number\})}
будет состоять из здания(\cl{building}) и набора комнат (\cl{room}), принадлежащих этому
зданию. Кроме того, этот набор комнат будет отсортирован в порядке возрастания (благодаря
модификатору \cl{asc}) по полю \cl{number} объекта \cl{room}.




\subsection{Настройка}
